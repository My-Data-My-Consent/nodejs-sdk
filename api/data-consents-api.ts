/* tslint:disable */
/* eslint-disable */
/**
 * My Data My Consent - Developer API
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DataConsentFinancialsDto } from '../models';
// @ts-ignore
import { DataConsentStatus } from '../models';
// @ts-ignore
import { FinancialAccount } from '../models';
// @ts-ignore
import { OrganizationFinancialAccountDto } from '../models';
// @ts-ignore
import { OrganizationFinancialTransactionsDtoPaginatedList } from '../models';
// @ts-ignore
import { UserAccountFinancialTransactionsDtoPaginatedList } from '../models';
/**
 * DataConsentsApi - axios parameter creator
 * @export
 */
export const DataConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId Data consent id.
         * @param {string} documentId Consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConsentedDocumentAnalysis: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('downloadConsentedDocumentAnalysis', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadConsentedDocumentAnalysis', 'documentId', documentId)
            const localVarPath = `/v1/consents/{consentId}/documents/{documentId}/analysis`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIndividualConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('downloadIndividualConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadIndividualConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents/{documentId}/download`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrganizationConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('downloadOrganizationConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadOrganizationConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents/{documentId}/download`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedFinancialAccounts: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getAllConsentedFinancialAccounts', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentFinancialAccounts: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentFinancialAccounts', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedAccountById: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedAccountById', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedAccountById', 'accountId', accountId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts/{accountId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents/{documentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccount: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedFinancialAccount', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedFinancialAccount', 'accountId', accountId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts/{accountId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountInsights: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountInsights', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountInsights', 'accountId', accountId)
            const localVarPath = `/v1/consents/{consentId}/financial-accounts/{accountId}/insights`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountTransactions: async (consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountTransactions', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountTransactions', 'accountId', accountId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts/{accountId}/transactions`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fromDateTimeUtc !== undefined) {
                localVarQueryParameter['fromDateTimeUtc'] = (fromDateTimeUtc as any instanceof Date) ?
                    (fromDateTimeUtc as any).toISOString() :
                    fromDateTimeUtc;
            }

            if (toDateTimeUtc !== undefined) {
                localVarQueryParameter['toDateTimeUtc'] = (toDateTimeUtc as any instanceof Date) ?
                    (toDateTimeUtc as any).toISOString() :
                    toDateTimeUtc;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GetIndividualDataConsents
         * @summary Get the paginated list of individual data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsents: async (status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/consents/individuals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromDateTime !== undefined) {
                localVarQueryParameter['fromDateTime'] = (fromDateTime as any instanceof Date) ?
                    (fromDateTime as any).toISOString() :
                    fromDateTime;
            }

            if (toDateTime !== undefined) {
                localVarQueryParameter['toDateTime'] = (toDateTime as any instanceof Date) ?
                    (toDateTime as any).toISOString() :
                    toDateTime;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented documents by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualConsentedDocuments: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getIndividualConsentedDocuments', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individuals data consent details by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualDataConsentById: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getIndividualDataConsentById', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConsentedAccountTransactions: async (consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrgConsentedAccountTransactions', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOrgConsentedAccountTransactions', 'accountId', accountId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts/{accountId}/transactions`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fromDateTimeUtc !== undefined) {
                localVarQueryParameter['fromDateTimeUtc'] = (fromDateTimeUtc as any instanceof Date) ?
                    (fromDateTimeUtc as any).toISOString() :
                    fromDateTimeUtc;
            }

            if (toDateTimeUtc !== undefined) {
                localVarQueryParameter['toDateTimeUtc'] = (toDateTimeUtc as any instanceof Date) ?
                    (toDateTimeUtc as any).toISOString() :
                    toDateTimeUtc;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrganizationConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getOrganizationConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents/{documentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consented documents by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocuments: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrganizationConsentedDocuments', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organizations data consent details by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDataConsentById: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrganizationDataConsentById', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the paginated list of organization data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDataConsents: async (status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/consents/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromDateTime !== undefined) {
                localVarQueryParameter['fromDateTime'] = (fromDateTime as any instanceof Date) ?
                    (fromDateTime as any).toISOString() :
                    fromDateTime;
            }

            if (toDateTime !== undefined) {
                localVarQueryParameter['toDateTime'] = (toDateTime as any instanceof Date) ?
                    (toDateTime as any).toISOString() :
                    toDateTime;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataConsentsApi - functional programming interface
 * @export
 */
export const DataConsentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataConsentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId Data consent id.
         * @param {string} documentId Consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadConsentedDocumentAnalysis(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadConsentedDocumentAnalysis(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadIndividualConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadIndividualConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOrganizationConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConsentedFinancialAccounts(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentFinancialsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConsentedFinancialAccounts(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentFinancialAccounts(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentFinancialsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentFinancialAccounts(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedAccountById(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedAccountById(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedFinancialAccount(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationFinancialAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedFinancialAccount(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedFinancialAccountInsights(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedFinancialAccountInsights(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccountFinancialTransactionsDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * GetIndividualDataConsents
         * @summary Get the paginated list of individual data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented documents by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualConsentedDocuments(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualConsentedDocuments(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individuals data consent details by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualDataConsentById(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualDataConsentById(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationFinancialTransactionsDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consented documents by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationConsentedDocuments(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationConsentedDocuments(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organizations data consent details by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationDataConsentById(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationDataConsentById(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the paginated list of organization data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationDataConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationDataConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataConsentsApi - factory interface
 * @export
 */
export const DataConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataConsentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId Data consent id.
         * @param {string} documentId Consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConsentedDocumentAnalysis(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.downloadConsentedDocumentAnalysis(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIndividualConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.downloadIndividualConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.downloadOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedFinancialAccounts(consentId: string, options?: any): AxiosPromise<DataConsentFinancialsDto> {
            return localVarFp.getAllConsentedFinancialAccounts(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentFinancialAccounts(consentId: string, options?: any): AxiosPromise<DataConsentFinancialsDto> {
            return localVarFp.getConsentFinancialAccounts(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedAccountById(consentId: string, accountId: string, options?: any): AxiosPromise<FinancialAccount> {
            return localVarFp.getConsentedAccountById(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented document by document id.
         * @param {string} consentId Individual data consent id.
         * @param {string} documentId Consented document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccount(consentId: string, accountId: string, options?: any): AxiosPromise<OrganizationFinancialAccountDto> {
            return localVarFp.getConsentedFinancialAccount(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountInsights(consentId: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getConsentedFinancialAccountInsights(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<UserAccountFinancialTransactionsDtoPaginatedList> {
            return localVarFp.getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * GetIndividualDataConsents
         * @summary Get the paginated list of individual data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<object> {
            return localVarFp.getConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented documents by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualConsentedDocuments(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getIndividualConsentedDocuments(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individuals data consent details by consent id.
         * @param {string} consentId Individual data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualDataConsentById(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getIndividualDataConsentById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<OrganizationFinancialTransactionsDtoPaginatedList> {
            return localVarFp.getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Organization data consent id.
         * @param {string} documentId Organization consented document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consented documents by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocuments(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getOrganizationConsentedDocuments(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organizations data consent details by consent id.
         * @param {string} consentId Organization data consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDataConsentById(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getOrganizationDataConsentById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the paginated list of organization data consents.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [fromDateTime] From datetime in UTC timezone.
         * @param {string} [toDateTime] To datetime in UTC timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDataConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<object> {
            return localVarFp.getOrganizationDataConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataConsentsApi - object-oriented interface
 * @export
 * @class DataConsentsApi
 * @extends {BaseAPI}
 */
export class DataConsentsApi extends BaseAPI {
    /**
     * 
     * @summary Get analysis of a consented document.
     * @param {string} consentId Data consent id.
     * @param {string} documentId Consented document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public downloadConsentedDocumentAnalysis(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).downloadConsentedDocumentAnalysis(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download individual consented document by document id.
     * @param {string} consentId Individual data consent id.
     * @param {string} documentId Consented document id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public downloadIndividualConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).downloadIndividualConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download organization consent document based on document id.
     * @param {string} consentId Organization data consent id.
     * @param {string} documentId Organization consented document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public downloadOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).downloadOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all individual consented financial accounts.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getAllConsentedFinancialAccounts(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getAllConsentedFinancialAccounts(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organizational consented financial accounts.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentFinancialAccounts(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentFinancialAccounts(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented financial account details based on account id.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedAccountById(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedAccountById(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented document by document id.
     * @param {string} consentId Individual data consent id.
     * @param {string} documentId Consented document id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consented financial account details based on account id.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedFinancialAccount(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedFinancialAccount(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consented financial account insights.
     * @param {string} consentId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedFinancialAccountInsights(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedFinancialAccountInsights(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented financial account transactions of an individual based on accountId.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {string} [filters] Filters.
     * @param {string} [fromDateTimeUtc] From date time in utc timezone.
     * @param {string} [toDateTimeUtc] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GetIndividualDataConsents
     * @summary Get the paginated list of individual data consents.
     * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
     * @param {string} [fromDateTime] From datetime in UTC timezone.
     * @param {string} [toDateTime] To datetime in UTC timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented documents by consent id.
     * @param {string} consentId Individual data consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getIndividualConsentedDocuments(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getIndividualConsentedDocuments(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individuals data consent details by consent id.
     * @param {string} consentId Individual data consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getIndividualDataConsentById(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getIndividualDataConsentById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consented financial account transactions of an individual based on accountId.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {string} [filters] Filters.
     * @param {string} [fromDateTimeUtc] From date time in utc timezone.
     * @param {string} [toDateTimeUtc] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consent document based on document id.
     * @param {string} consentId Organization data consent id.
     * @param {string} documentId Organization consented document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consented documents by consent id.
     * @param {string} consentId Organization data consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationConsentedDocuments(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationConsentedDocuments(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organizations data consent details by consent id.
     * @param {string} consentId Organization data consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationDataConsentById(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationDataConsentById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the paginated list of organization data consents.
     * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
     * @param {string} [fromDateTime] From datetime in UTC timezone.
     * @param {string} [toDateTime] To datetime in UTC timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationDataConsents(status?: DataConsentStatus, fromDateTime?: string, toDateTime?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationDataConsents(status, fromDateTime, toDateTime, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}
