/* tslint:disable */
/* eslint-disable */
/**
 * My Data My Consent - Developer API
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DataConsentStatus } from '../models';
// @ts-ignore
import { ProblemDetails } from '../models';
/**
 * DataConsentsApi - axios parameter creator
 * @export
 */
export const DataConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get consented financial account details.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdGet: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdGet', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdGet', 'accountId', accountId)
            const localVarPath = `/v1/consents/{consentId}/accounts/{accountId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdInsightsGet: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdInsightsGet', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdInsightsGet', 'accountId', accountId)
            const localVarPath = `/v1/consents/{consentId}/accounts/{accountId}/insights`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consented financial account transactions.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {string} [filters] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdTransactionsGet: async (consentId: string, accountId: string, filters?: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdTransactionsGet', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsAccountIdTransactionsGet', 'accountId', accountId)
            const localVarPath = `/v1/consents/{consentId}/accounts/{accountId}/transactions`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all accounts in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsGet: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdAccountsGet', 'consentId', consentId)
            const localVarPath = `/v1/consents/{consentId}/accounts`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet', 'documentId', documentId)
            const localVarPath = `/v1/consents/{consentId}/documents/{documentId}/analysis`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdDownloadGet: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdDownloadGet', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdDownloadGet', 'documentId', documentId)
            const localVarPath = `/v1/consents/{consentId}/documents/{documentId}/download`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consented document details.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdGet: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdGet', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsDocumentIdGet', 'documentId', documentId)
            const localVarPath = `/v1/consents/{consentId}/documents/{documentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all documents in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsGet: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdDocumentsGet', 'consentId', consentId)
            const localVarPath = `/v1/consents/{consentId}/documents`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consent details by consent id.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdGet: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('v1ConsentsConsentIdGet', 'consentId', consentId)
            const localVarPath = `/v1/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all consents filtered by status and time.
         * @param {DataConsentStatus} [status] MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [startDate] System.DateTime.
         * @param {string} [endDate] till dateSystem.DateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsGet: async (status?: DataConsentStatus, startDate?: string, endDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataConsentsApi - functional programming interface
 * @export
 */
export const DataConsentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataConsentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get consented financial account details.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdAccountsAccountIdGet(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdAccountsAccountIdGet(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get consented financial account transactions.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {string} [filters] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId: string, accountId: string, filters?: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId, accountId, filters, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all accounts in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdAccountsGet(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdAccountsGet(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get consented document details.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdDocumentsDocumentIdGet(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdDocumentsDocumentIdGet(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all documents in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdDocumentsGet(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdDocumentsGet(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get consent details by consent id.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsConsentIdGet(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsConsentIdGet(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all consents filtered by status and time.
         * @param {DataConsentStatus} [status] MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [startDate] System.DateTime.
         * @param {string} [endDate] till dateSystem.DateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ConsentsGet(status?: DataConsentStatus, startDate?: string, endDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ConsentsGet(status, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataConsentsApi - factory interface
 * @export
 */
export const DataConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataConsentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get consented financial account details.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdGet(consentId: string, accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdAccountsAccountIdGet(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consented financial account insights.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId: string, accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consented financial account transactions.
         * @param {string} consentId 
         * @param {string} accountId 
         * @param {string} [filters] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId: string, accountId: string, filters?: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId, accountId, filters, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all accounts in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdAccountsGet(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdAccountsGet(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get analysis of a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a consented document.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consented document details.
         * @param {string} consentId 
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsDocumentIdGet(consentId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdDocumentsDocumentIdGet(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all documents in a consent.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdDocumentsGet(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdDocumentsGet(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consent details by consent id.
         * @param {string} consentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsConsentIdGet(consentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsConsentIdGet(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all consents filtered by status and time.
         * @param {DataConsentStatus} [status] MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [startDate] System.DateTime.
         * @param {string} [endDate] till dateSystem.DateTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ConsentsGet(status?: DataConsentStatus, startDate?: string, endDate?: string, options?: any): AxiosPromise<object> {
            return localVarFp.v1ConsentsGet(status, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataConsentsApi - object-oriented interface
 * @export
 * @class DataConsentsApi
 * @extends {BaseAPI}
 */
export class DataConsentsApi extends BaseAPI {
    /**
     * 
     * @summary Get consented financial account details.
     * @param {string} consentId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdAccountsAccountIdGet(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdAccountsAccountIdGet(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consented financial account insights.
     * @param {string} consentId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdAccountsAccountIdInsightsGet(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consented financial account transactions.
     * @param {string} consentId 
     * @param {string} accountId 
     * @param {string} [filters] 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId: string, accountId: string, filters?: string, fromDate?: string, toDate?: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdAccountsAccountIdTransactionsGet(consentId, accountId, filters, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all accounts in a consent.
     * @param {string} consentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdAccountsGet(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdAccountsGet(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get analysis of a consented document.
     * @param {string} consentId 
     * @param {string} documentId Document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a consented document.
     * @param {string} consentId 
     * @param {string} documentId Document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdDocumentsDocumentIdDownloadGet(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consented document details.
     * @param {string} consentId 
     * @param {string} documentId Document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdDocumentsDocumentIdGet(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdDocumentsDocumentIdGet(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all documents in a consent.
     * @param {string} consentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdDocumentsGet(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdDocumentsGet(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consent details by consent id.
     * @param {string} consentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsConsentIdGet(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsConsentIdGet(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all consents filtered by status and time.
     * @param {DataConsentStatus} [status] MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
     * @param {string} [startDate] System.DateTime.
     * @param {string} [endDate] till dateSystem.DateTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public v1ConsentsGet(status?: DataConsentStatus, startDate?: string, endDate?: string, options?: any) {
        return DataConsentsApiFp(this.configuration).v1ConsentsGet(status, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}
