/* tslint:disable */
/* eslint-disable */
/**
 * My Data My Consent - Developer API
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DataConsentDetailsDto } from '../models';
// @ts-ignore
import { DataConsentDocumentsDto } from '../models';
// @ts-ignore
import { DataConsentFinancialsDto } from '../models';
// @ts-ignore
import { DataConsentStatus } from '../models';
// @ts-ignore
import { FinancialAccount } from '../models';
// @ts-ignore
import { OrganizationDataConsentInfoDtoPaginatedList } from '../models';
// @ts-ignore
import { OrganizationDocumentDetails } from '../models';
// @ts-ignore
import { OrganizationDocumentDownloadDto } from '../models';
// @ts-ignore
import { OrganizationFinancialAccountDto } from '../models';
// @ts-ignore
import { OrganizationFinancialTransactionsDtoPaginatedList } from '../models';
// @ts-ignore
import { UserAccountFinancialTransactionsDtoPaginatedList } from '../models';
// @ts-ignore
import { UserDataConsentInfoDtoPaginatedList } from '../models';
// @ts-ignore
import { UserDocumentDetails } from '../models';
// @ts-ignore
import { UserDocumentDownload } from '../models';
/**
 * DataConsentsApi - axios parameter creator
 * @export
 */
export const DataConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Download a individuals consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('downloadConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents/{documentId}/download`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a organizations consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrgConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('downloadOrgConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadOrgConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents/{documentId}/download`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the individual documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedDocuments: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getAllConsentedDocuments', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedFinancialAccounts: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getAllConsentedFinancialAccounts', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the organization documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizationConsentedDocuments: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getAllOrganizationConsentedDocuments', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all individuals consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentDetailsById: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentDetailsById', 'consentId', consentId)
            const localVarPath = `/v1/consents/individuals/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentFinancialAccounts: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentFinancialAccounts', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedAccountById: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedAccountById', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedAccountById', 'accountId', accountId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts/{accountId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individuals consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/individuals/{consentId}/documents/{documentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccount: async (consentId: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedFinancialAccount', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedFinancialAccount', 'accountId', accountId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts/{accountId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountTransactions: async (consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountTransactions', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getConsentedFinancialAccountTransactions', 'accountId', accountId)
            const localVarPath = `/v1/consents/individuals/{consentId}/financial-accounts/{accountId}/transactions`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fromDateTimeUtc !== undefined) {
                localVarQueryParameter['fromDateTimeUtc'] = (fromDateTimeUtc as any instanceof Date) ?
                    (fromDateTimeUtc as any).toISOString() :
                    fromDateTimeUtc;
            }

            if (toDateTimeUtc !== undefined) {
                localVarQueryParameter['toDateTimeUtc'] = (toDateTimeUtc as any instanceof Date) ?
                    (toDateTimeUtc as any).toISOString() :
                    toDateTimeUtc;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of data consents sent for organizations.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentsForOrganizations: async (status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/consents/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of Consents Sent to Individuals.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentsSentToIndividuals: async (status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/consents/individuals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConsentedAccountTransactions: async (consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrgConsentedAccountTransactions', 'consentId', consentId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOrgConsentedAccountTransactions', 'accountId', accountId)
            const localVarPath = `/v1/consents/organizations/{consentId}/financial-accounts/{accountId}/transactions`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fromDateTimeUtc !== undefined) {
                localVarQueryParameter['fromDateTimeUtc'] = (fromDateTimeUtc as any instanceof Date) ?
                    (fromDateTimeUtc as any).toISOString() :
                    fromDateTimeUtc;
            }

            if (toDateTimeUtc !== undefined) {
                localVarQueryParameter['toDateTimeUtc'] = (toDateTimeUtc as any instanceof Date) ?
                    (toDateTimeUtc as any).toISOString() :
                    toDateTimeUtc;
            }

            if (pageNo !== undefined) {
                localVarQueryParameter['pageNo'] = pageNo;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all organization consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentDetailsById: async (consentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrganizationConsentDetailsById', 'consentId', consentId)
            const localVarPath = `/v1/consents/organizations/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocumentById: async (consentId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getOrganizationConsentedDocumentById', 'consentId', consentId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getOrganizationConsentedDocumentById', 'documentId', documentId)
            const localVarPath = `/v1/consents/organizations/{consentId}/documents/{documentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataConsentsApi - functional programming interface
 * @export
 */
export const DataConsentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataConsentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Download a individuals consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentDownload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a organizations consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOrgConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDocumentDownloadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOrgConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the individual documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConsentedDocuments(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentDocumentsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConsentedDocuments(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConsentedFinancialAccounts(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentFinancialsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConsentedFinancialAccounts(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the organization documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrganizationConsentedDocuments(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentDocumentsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrganizationConsentedDocuments(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all individuals consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentDetailsById(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentDetailsById(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentFinancialAccounts(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentFinancialsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentFinancialAccounts(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedAccountById(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedAccountById(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individuals consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDocumentDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedFinancialAccount(consentId: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationFinancialAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedFinancialAccount(consentId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccountFinancialTransactionsDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of data consents sent for organizations.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentsForOrganizations(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDataConsentInfoDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentsForOrganizations(status, from, to, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of Consents Sent to Individuals.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentsSentToIndividuals(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataConsentInfoDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentsSentToIndividuals(status, from, to, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationFinancialTransactionsDtoPaginatedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all organization consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationConsentDetailsById(consentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataConsentDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationConsentDetailsById(consentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDocumentDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationConsentedDocumentById(consentId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataConsentsApi - factory interface
 * @export
 */
export const DataConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataConsentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Download a individuals consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<UserDocumentDownload> {
            return localVarFp.downloadConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a organizations consented document.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrgConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<OrganizationDocumentDownloadDto> {
            return localVarFp.downloadOrgConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the individual documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedDocuments(consentId: string, options?: any): AxiosPromise<DataConsentDocumentsDto> {
            return localVarFp.getAllConsentedDocuments(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all individual consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConsentedFinancialAccounts(consentId: string, options?: any): AxiosPromise<DataConsentFinancialsDto> {
            return localVarFp.getAllConsentedFinancialAccounts(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the organization documents based on ConsentId.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizationConsentedDocuments(consentId: string, options?: any): AxiosPromise<DataConsentDocumentsDto> {
            return localVarFp.getAllOrganizationConsentedDocuments(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all individuals consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentDetailsById(consentId: string, options?: any): AxiosPromise<DataConsentDetailsDto> {
            return localVarFp.getConsentDetailsById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organizational consented financial accounts.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentFinancialAccounts(consentId: string, options?: any): AxiosPromise<DataConsentFinancialsDto> {
            return localVarFp.getConsentFinancialAccounts(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedAccountById(consentId: string, accountId: string, options?: any): AxiosPromise<FinancialAccount> {
            return localVarFp.getConsentedAccountById(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individuals consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<UserDocumentDetails> {
            return localVarFp.getConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consented financial account details based on account id.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccount(consentId: string, accountId: string, options?: any): AxiosPromise<OrganizationFinancialAccountDto> {
            return localVarFp.getConsentedFinancialAccount(consentId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get individual consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<UserAccountFinancialTransactionsDtoPaginatedList> {
            return localVarFp.getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of data consents sent for organizations.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentsForOrganizations(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<OrganizationDataConsentInfoDtoPaginatedList> {
            return localVarFp.getConsentsForOrganizations(status, from, to, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of Consents Sent to Individuals.
         * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
         * @param {string} [from] From date time in utc timezone.
         * @param {string} [to] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentsSentToIndividuals(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<UserDataConsentInfoDtoPaginatedList> {
            return localVarFp.getConsentsSentToIndividuals(status, from, to, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consented financial account transactions of an individual based on accountId.
         * @param {string} consentId Consent id.
         * @param {string} accountId Account id.
         * @param {string} [filters] Filters.
         * @param {string} [fromDateTimeUtc] From date time in utc timezone.
         * @param {string} [toDateTimeUtc] Til date time in utc timezone.
         * @param {number} [pageNo] Page number.
         * @param {number} [pageSize] Number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any): AxiosPromise<OrganizationFinancialTransactionsDtoPaginatedList> {
            return localVarFp.getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all organization consent details by consent id.
         * @param {string} consentId Consent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentDetailsById(consentId: string, options?: any): AxiosPromise<DataConsentDetailsDto> {
            return localVarFp.getOrganizationConsentDetailsById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization consent document based on document id.
         * @param {string} consentId Consent id.
         * @param {string} documentId Document Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any): AxiosPromise<OrganizationDocumentDetails> {
            return localVarFp.getOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataConsentsApi - object-oriented interface
 * @export
 * @class DataConsentsApi
 * @extends {BaseAPI}
 */
export class DataConsentsApi extends BaseAPI {
    /**
     * 
     * @summary Download a individuals consented document.
     * @param {string} consentId Consent id.
     * @param {string} documentId Document id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public downloadConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).downloadConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a organizations consented document.
     * @param {string} consentId Consent id.
     * @param {string} documentId Document id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public downloadOrgConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).downloadOrgConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the individual documents based on ConsentId.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getAllConsentedDocuments(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getAllConsentedDocuments(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all individual consented financial accounts.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getAllConsentedFinancialAccounts(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getAllConsentedFinancialAccounts(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the organization documents based on ConsentId.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getAllOrganizationConsentedDocuments(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getAllOrganizationConsentedDocuments(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all individuals consent details by consent id.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentDetailsById(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentDetailsById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organizational consented financial accounts.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentFinancialAccounts(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentFinancialAccounts(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented financial account details based on account id.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedAccountById(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedAccountById(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individuals consent document based on document id.
     * @param {string} consentId Consent id.
     * @param {string} documentId Document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consented financial account details based on account id.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedFinancialAccount(consentId: string, accountId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedFinancialAccount(consentId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get individual consented financial account transactions of an individual based on accountId.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {string} [filters] Filters.
     * @param {string} [fromDateTimeUtc] From date time in utc timezone.
     * @param {string} [toDateTimeUtc] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentedFinancialAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentedFinancialAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of data consents sent for organizations.
     * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
     * @param {string} [from] From date time in utc timezone.
     * @param {string} [to] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentsForOrganizations(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentsForOrganizations(status, from, to, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of Consents Sent to Individuals.
     * @param {DataConsentStatus} [status] Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus.
     * @param {string} [from] From date time in utc timezone.
     * @param {string} [to] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getConsentsSentToIndividuals(status?: DataConsentStatus, from?: string, to?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getConsentsSentToIndividuals(status, from, to, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consented financial account transactions of an individual based on accountId.
     * @param {string} consentId Consent id.
     * @param {string} accountId Account id.
     * @param {string} [filters] Filters.
     * @param {string} [fromDateTimeUtc] From date time in utc timezone.
     * @param {string} [toDateTimeUtc] Til date time in utc timezone.
     * @param {number} [pageNo] Page number.
     * @param {number} [pageSize] Number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrgConsentedAccountTransactions(consentId: string, accountId: string, filters?: string, fromDateTimeUtc?: string, toDateTimeUtc?: string, pageNo?: number, pageSize?: number, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrgConsentedAccountTransactions(consentId, accountId, filters, fromDateTimeUtc, toDateTimeUtc, pageNo, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all organization consent details by consent id.
     * @param {string} consentId Consent id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationConsentDetailsById(consentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationConsentDetailsById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization consent document based on document id.
     * @param {string} consentId Consent id.
     * @param {string} documentId Document Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataConsentsApi
     */
    public getOrganizationConsentedDocumentById(consentId: string, documentId: string, options?: any) {
        return DataConsentsApiFp(this.configuration).getOrganizationConsentedDocumentById(consentId, documentId, options).then((request) => request(this.axios, this.basePath));
    }
}
